/* tslint:disable */
/* eslint-disable */
/**
 * Tampa Events API
 * Community events aggregation API for Tampa Bay tech meetups and events
 *
 * The version of the OpenAPI document: 2026-01-25
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface V20260125EventsGet200ResponseInner {
    'id': string;
    'title': string;
    'description'?: string;
    'dateTime': string;
    'duration'?: string;
    'eventUrl': string;
    'status': V20260125EventsGet200ResponseInnerStatusEnum;
    'eventType'?: V20260125EventsGet200ResponseInnerEventTypeEnum;
    'rsvpCount': number;
    'venues': Array<any>;
    'photo'?: any;
    'group'?: any;
    'address'?: string;
    'googleMapsUrl'?: string;
    'photoUrl'?: string;
    'isOnline': boolean;
}

export const V20260125EventsGet200ResponseInnerStatusEnum = {
    Active: 'ACTIVE',
    Cancelled: 'CANCELLED',
    Draft: 'DRAFT'
} as const;

export type V20260125EventsGet200ResponseInnerStatusEnum = typeof V20260125EventsGet200ResponseInnerStatusEnum[keyof typeof V20260125EventsGet200ResponseInnerStatusEnum];
export const V20260125EventsGet200ResponseInnerEventTypeEnum = {
    Physical: 'PHYSICAL',
    Online: 'ONLINE',
    Hybrid: 'HYBRID'
} as const;

export type V20260125EventsGet200ResponseInnerEventTypeEnum = typeof V20260125EventsGet200ResponseInnerEventTypeEnum[keyof typeof V20260125EventsGet200ResponseInnerEventTypeEnum];

export interface V20260125SchemasGet200Response {
    'schemas': Array<V20260125SchemasGet200ResponseSchemasInner>;
    'version': string;
}
export interface V20260125SchemasGet200ResponseSchemasInner {
    'name': string;
    'title': string;
    'description': string;
    'url': string;
}
export interface V20260125SchemasNameGet404Response {
    'error': string;
    'available': Array<string>;
}
export interface VServiceStatusGet200Response {
    'platforms': Array<VServiceStatusGet200ResponsePlatformsInner>;
    'groups': Array<VServiceStatusGet200ResponseGroupsInner>;
    'totalGroups': number;
    'aggregation'?: VServiceStatusGet200ResponseAggregation;
}
export interface VServiceStatusGet200ResponseAggregation {
    'lastRunAt'?: string;
    'durationMs'?: number;
    'groupsProcessed'?: number;
    'groupsFailed'?: number;
    'dataHash'?: string;
    'errors': Array<string>;
}
export interface VServiceStatusGet200ResponseGroupsInner {
    'urlname': string;
    'platform': string;
}
export interface VServiceStatusGet200ResponsePlatformsInner {
    'name': string;
    'configured': boolean;
}

/**
 * EventsApi - axios parameter creator
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of all upcoming events, optionally filtered by query parameters
         * @summary Get all events
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _20260125eventsGet: async (groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/2026-01-25/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (groups !== undefined) {
                localVarQueryParameter['groups'] = groups;
            }

            if (noonline !== undefined) {
                localVarQueryParameter['noonline'] = noonline;
            }

            if (withinHours !== undefined) {
                localVarQueryParameter['within_hours'] = withinHours;
            }

            if (withinDays !== undefined) {
                localVarQueryParameter['within_days'] = withinDays;
            }

            if (noempty !== undefined) {
                localVarQueryParameter['noempty'] = noempty;
            }

            localVarHeaderParameter['Accept'] = 'application/json,text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns one upcoming event for each group (the next event)
         * @summary Get next event per group
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _20260125eventsNextGet: async (groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/2026-01-25/events/next`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (groups !== undefined) {
                localVarQueryParameter['groups'] = groups;
            }

            if (noonline !== undefined) {
                localVarQueryParameter['noonline'] = noonline;
            }

            if (withinHours !== undefined) {
                localVarQueryParameter['within_hours'] = withinHours;
            }

            if (withinDays !== undefined) {
                localVarQueryParameter['within_days'] = withinDays;
            }

            if (noempty !== undefined) {
                localVarQueryParameter['noempty'] = noempty;
            }

            localVarHeaderParameter['Accept'] = 'application/json,text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of all upcoming events, optionally filtered by query parameters
         * @summary Get all events
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _20260125eventsGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V20260125EventsGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._20260125eventsGet(groups, noonline, withinHours, withinDays, noempty, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi._20260125eventsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns one upcoming event for each group (the next event)
         * @summary Get next event per group
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _20260125eventsNextGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V20260125EventsGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._20260125eventsNextGet(groups, noonline, withinHours, withinDays, noempty, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi._20260125eventsNextGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventsApi - factory interface
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * Returns a list of all upcoming events, optionally filtered by query parameters
         * @summary Get all events
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _20260125eventsGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<V20260125EventsGet200ResponseInner>> {
            return localVarFp._20260125eventsGet(groups, noonline, withinHours, withinDays, noempty, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns one upcoming event for each group (the next event)
         * @summary Get next event per group
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _20260125eventsNextGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<V20260125EventsGet200ResponseInner>> {
            return localVarFp._20260125eventsNextGet(groups, noonline, withinHours, withinDays, noempty, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 */
export class EventsApi extends BaseAPI {
    /**
     * Returns a list of all upcoming events, optionally filtered by query parameters
     * @summary Get all events
     * @param {string} [groups] 
     * @param {string} [noonline] 
     * @param {string} [withinHours] 
     * @param {string} [withinDays] 
     * @param {string} [noempty] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public _20260125eventsGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration)._20260125eventsGet(groups, noonline, withinHours, withinDays, noempty, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns one upcoming event for each group (the next event)
     * @summary Get next event per group
     * @param {string} [groups] 
     * @param {string} [noonline] 
     * @param {string} [withinHours] 
     * @param {string} [withinDays] 
     * @param {string} [noempty] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public _20260125eventsNextGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration)._20260125eventsNextGet(groups, noonline, withinHours, withinDays, noempty, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FeedsApi - axios parameter creator
 */
export const FeedsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Alias for /rss - returns events as an RSS 2.0 feed
         * @summary Get RSS feed (alias)
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _20260125feedGet: async (groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/2026-01-25/feed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (groups !== undefined) {
                localVarQueryParameter['groups'] = groups;
            }

            if (noonline !== undefined) {
                localVarQueryParameter['noonline'] = noonline;
            }

            if (withinHours !== undefined) {
                localVarQueryParameter['within_hours'] = withinHours;
            }

            if (withinDays !== undefined) {
                localVarQueryParameter['within_days'] = withinDays;
            }

            if (noempty !== undefined) {
                localVarQueryParameter['noempty'] = noempty;
            }

            localVarHeaderParameter['Accept'] = 'application/rss+xml';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Alias for /ics - returns events as an iCalendar (.ics) feed
         * @summary Get iCalendar feed (alias)
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _20260125icalGet: async (groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/2026-01-25/ical`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (groups !== undefined) {
                localVarQueryParameter['groups'] = groups;
            }

            if (noonline !== undefined) {
                localVarQueryParameter['noonline'] = noonline;
            }

            if (withinHours !== undefined) {
                localVarQueryParameter['within_hours'] = withinHours;
            }

            if (withinDays !== undefined) {
                localVarQueryParameter['within_days'] = withinDays;
            }

            if (noempty !== undefined) {
                localVarQueryParameter['noempty'] = noempty;
            }

            localVarHeaderParameter['Accept'] = 'text/calendar';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns events as an iCalendar (.ics) feed
         * @summary Get iCalendar feed
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _20260125icsGet: async (groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/2026-01-25/ics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (groups !== undefined) {
                localVarQueryParameter['groups'] = groups;
            }

            if (noonline !== undefined) {
                localVarQueryParameter['noonline'] = noonline;
            }

            if (withinHours !== undefined) {
                localVarQueryParameter['within_hours'] = withinHours;
            }

            if (withinDays !== undefined) {
                localVarQueryParameter['within_days'] = withinDays;
            }

            if (noempty !== undefined) {
                localVarQueryParameter['noempty'] = noempty;
            }

            localVarHeaderParameter['Accept'] = 'text/calendar';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns events as an RSS 2.0 feed
         * @summary Get RSS feed
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _20260125rssGet: async (groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/2026-01-25/rss`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (groups !== undefined) {
                localVarQueryParameter['groups'] = groups;
            }

            if (noonline !== undefined) {
                localVarQueryParameter['noonline'] = noonline;
            }

            if (withinHours !== undefined) {
                localVarQueryParameter['within_hours'] = withinHours;
            }

            if (withinDays !== undefined) {
                localVarQueryParameter['within_days'] = withinDays;
            }

            if (noempty !== undefined) {
                localVarQueryParameter['noempty'] = noempty;
            }

            localVarHeaderParameter['Accept'] = 'application/rss+xml';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns events as an iCalendar feed (same as /ics, for webcal:// protocol)
         * @summary Get webcal feed
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _20260125webcalGet: async (groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/2026-01-25/webcal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (groups !== undefined) {
                localVarQueryParameter['groups'] = groups;
            }

            if (noonline !== undefined) {
                localVarQueryParameter['noonline'] = noonline;
            }

            if (withinHours !== undefined) {
                localVarQueryParameter['within_hours'] = withinHours;
            }

            if (withinDays !== undefined) {
                localVarQueryParameter['within_days'] = withinDays;
            }

            if (noempty !== undefined) {
                localVarQueryParameter['noempty'] = noempty;
            }

            localVarHeaderParameter['Accept'] = 'text/calendar';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedsApi - functional programming interface
 */
export const FeedsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeedsApiAxiosParamCreator(configuration)
    return {
        /**
         * Alias for /rss - returns events as an RSS 2.0 feed
         * @summary Get RSS feed (alias)
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _20260125feedGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._20260125feedGet(groups, noonline, withinHours, withinDays, noempty, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedsApi._20260125feedGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Alias for /ics - returns events as an iCalendar (.ics) feed
         * @summary Get iCalendar feed (alias)
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _20260125icalGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._20260125icalGet(groups, noonline, withinHours, withinDays, noempty, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedsApi._20260125icalGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns events as an iCalendar (.ics) feed
         * @summary Get iCalendar feed
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _20260125icsGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._20260125icsGet(groups, noonline, withinHours, withinDays, noempty, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedsApi._20260125icsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns events as an RSS 2.0 feed
         * @summary Get RSS feed
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _20260125rssGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._20260125rssGet(groups, noonline, withinHours, withinDays, noempty, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedsApi._20260125rssGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns events as an iCalendar feed (same as /ics, for webcal:// protocol)
         * @summary Get webcal feed
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _20260125webcalGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._20260125webcalGet(groups, noonline, withinHours, withinDays, noempty, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedsApi._20260125webcalGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FeedsApi - factory interface
 */
export const FeedsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeedsApiFp(configuration)
    return {
        /**
         * Alias for /rss - returns events as an RSS 2.0 feed
         * @summary Get RSS feed (alias)
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _20260125feedGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp._20260125feedGet(groups, noonline, withinHours, withinDays, noempty, options).then((request) => request(axios, basePath));
        },
        /**
         * Alias for /ics - returns events as an iCalendar (.ics) feed
         * @summary Get iCalendar feed (alias)
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _20260125icalGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp._20260125icalGet(groups, noonline, withinHours, withinDays, noempty, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns events as an iCalendar (.ics) feed
         * @summary Get iCalendar feed
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _20260125icsGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp._20260125icsGet(groups, noonline, withinHours, withinDays, noempty, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns events as an RSS 2.0 feed
         * @summary Get RSS feed
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _20260125rssGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp._20260125rssGet(groups, noonline, withinHours, withinDays, noempty, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns events as an iCalendar feed (same as /ics, for webcal:// protocol)
         * @summary Get webcal feed
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _20260125webcalGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp._20260125webcalGet(groups, noonline, withinHours, withinDays, noempty, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeedsApi - object-oriented interface
 */
export class FeedsApi extends BaseAPI {
    /**
     * Alias for /rss - returns events as an RSS 2.0 feed
     * @summary Get RSS feed (alias)
     * @param {string} [groups] 
     * @param {string} [noonline] 
     * @param {string} [withinHours] 
     * @param {string} [withinDays] 
     * @param {string} [noempty] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public _20260125feedGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig) {
        return FeedsApiFp(this.configuration)._20260125feedGet(groups, noonline, withinHours, withinDays, noempty, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Alias for /ics - returns events as an iCalendar (.ics) feed
     * @summary Get iCalendar feed (alias)
     * @param {string} [groups] 
     * @param {string} [noonline] 
     * @param {string} [withinHours] 
     * @param {string} [withinDays] 
     * @param {string} [noempty] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public _20260125icalGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig) {
        return FeedsApiFp(this.configuration)._20260125icalGet(groups, noonline, withinHours, withinDays, noempty, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns events as an iCalendar (.ics) feed
     * @summary Get iCalendar feed
     * @param {string} [groups] 
     * @param {string} [noonline] 
     * @param {string} [withinHours] 
     * @param {string} [withinDays] 
     * @param {string} [noempty] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public _20260125icsGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig) {
        return FeedsApiFp(this.configuration)._20260125icsGet(groups, noonline, withinHours, withinDays, noempty, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns events as an RSS 2.0 feed
     * @summary Get RSS feed
     * @param {string} [groups] 
     * @param {string} [noonline] 
     * @param {string} [withinHours] 
     * @param {string} [withinDays] 
     * @param {string} [noempty] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public _20260125rssGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig) {
        return FeedsApiFp(this.configuration)._20260125rssGet(groups, noonline, withinHours, withinDays, noempty, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns events as an iCalendar feed (same as /ics, for webcal:// protocol)
     * @summary Get webcal feed
     * @param {string} [groups] 
     * @param {string} [noonline] 
     * @param {string} [withinHours] 
     * @param {string} [withinDays] 
     * @param {string} [noempty] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public _20260125webcalGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig) {
        return FeedsApiFp(this.configuration)._20260125webcalGet(groups, noonline, withinHours, withinDays, noempty, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PagesApi - axios parameter creator
 */
export const PagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a formatted HTML page displaying upcoming events
         * @summary HTML page with upcoming events
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        htmlGet: async (groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (groups !== undefined) {
                localVarQueryParameter['groups'] = groups;
            }

            if (noonline !== undefined) {
                localVarQueryParameter['noonline'] = noonline;
            }

            if (withinHours !== undefined) {
                localVarQueryParameter['within_hours'] = withinHours;
            }

            if (withinDays !== undefined) {
                localVarQueryParameter['within_days'] = withinDays;
            }

            if (noempty !== undefined) {
                localVarQueryParameter['noempty'] = noempty;
            }

            localVarHeaderParameter['Accept'] = 'text/html';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Alias for /html - returns a formatted HTML page displaying upcoming events
         * @summary Upcoming events HTML page
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upcomingEventsGet: async (groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/upcoming-events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (groups !== undefined) {
                localVarQueryParameter['groups'] = groups;
            }

            if (noonline !== undefined) {
                localVarQueryParameter['noonline'] = noonline;
            }

            if (withinHours !== undefined) {
                localVarQueryParameter['within_hours'] = withinHours;
            }

            if (withinDays !== undefined) {
                localVarQueryParameter['within_days'] = withinDays;
            }

            if (noempty !== undefined) {
                localVarQueryParameter['noempty'] = noempty;
            }

            localVarHeaderParameter['Accept'] = 'text/html';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PagesApi - functional programming interface
 */
export const PagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a formatted HTML page displaying upcoming events
         * @summary HTML page with upcoming events
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async htmlGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.htmlGet(groups, noonline, withinHours, withinDays, noempty, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.htmlGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Alias for /html - returns a formatted HTML page displaying upcoming events
         * @summary Upcoming events HTML page
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upcomingEventsGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upcomingEventsGet(groups, noonline, withinHours, withinDays, noempty, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.upcomingEventsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PagesApi - factory interface
 */
export const PagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PagesApiFp(configuration)
    return {
        /**
         * Returns a formatted HTML page displaying upcoming events
         * @summary HTML page with upcoming events
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        htmlGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.htmlGet(groups, noonline, withinHours, withinDays, noempty, options).then((request) => request(axios, basePath));
        },
        /**
         * Alias for /html - returns a formatted HTML page displaying upcoming events
         * @summary Upcoming events HTML page
         * @param {string} [groups] 
         * @param {string} [noonline] 
         * @param {string} [withinHours] 
         * @param {string} [withinDays] 
         * @param {string} [noempty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upcomingEventsGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.upcomingEventsGet(groups, noonline, withinHours, withinDays, noempty, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PagesApi - object-oriented interface
 */
export class PagesApi extends BaseAPI {
    /**
     * Returns a formatted HTML page displaying upcoming events
     * @summary HTML page with upcoming events
     * @param {string} [groups] 
     * @param {string} [noonline] 
     * @param {string} [withinHours] 
     * @param {string} [withinDays] 
     * @param {string} [noempty] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public htmlGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).htmlGet(groups, noonline, withinHours, withinDays, noempty, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Alias for /html - returns a formatted HTML page displaying upcoming events
     * @summary Upcoming events HTML page
     * @param {string} [groups] 
     * @param {string} [noonline] 
     * @param {string} [withinHours] 
     * @param {string} [withinDays] 
     * @param {string} [noempty] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public upcomingEventsGet(groups?: string, noonline?: string, withinHours?: string, withinDays?: string, noempty?: string, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).upcomingEventsGet(groups, noonline, withinHours, withinDays, noempty, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SchemasApi - axios parameter creator
 */
export const SchemasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns metadata about all available JSON schemas for the API models
         * @summary List all JSON schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _20260125schemasGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/2026-01-25/schemas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the JSON Schema for a specific model type
         * @summary Get specific JSON schema
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _20260125schemasNameGet: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('_20260125schemasNameGet', 'name', name)
            const localVarPath = `/2026-01-25/schemas/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/schema+json,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemasApi - functional programming interface
 */
export const SchemasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemasApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns metadata about all available JSON schemas for the API models
         * @summary List all JSON schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _20260125schemasGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V20260125SchemasGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._20260125schemasGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemasApi._20260125schemasGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the JSON Schema for a specific model type
         * @summary Get specific JSON schema
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _20260125schemasNameGet(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._20260125schemasNameGet(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemasApi._20260125schemasNameGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SchemasApi - factory interface
 */
export const SchemasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemasApiFp(configuration)
    return {
        /**
         * Returns metadata about all available JSON schemas for the API models
         * @summary List all JSON schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _20260125schemasGet(options?: RawAxiosRequestConfig): AxiosPromise<V20260125SchemasGet200Response> {
            return localVarFp._20260125schemasGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the JSON Schema for a specific model type
         * @summary Get specific JSON schema
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _20260125schemasNameGet(name: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp._20260125schemasNameGet(name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemasApi - object-oriented interface
 */
export class SchemasApi extends BaseAPI {
    /**
     * Returns metadata about all available JSON schemas for the API models
     * @summary List all JSON schemas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public _20260125schemasGet(options?: RawAxiosRequestConfig) {
        return SchemasApiFp(this.configuration)._20260125schemasGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the JSON Schema for a specific model type
     * @summary Get specific JSON schema
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public _20260125schemasNameGet(name: string, options?: RawAxiosRequestConfig) {
        return SchemasApiFp(this.configuration)._20260125schemasNameGet(name, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServiceApi - axios parameter creator
 */
export const ServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns service status and configuration information, including platforms, groups, and aggregation diagnostics.
         * @summary Service status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceStatusGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/service/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceApi - functional programming interface
 */
export const ServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns service status and configuration information, including platforms, groups, and aggregation diagnostics.
         * @summary Service status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceStatusGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VServiceStatusGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceStatusGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceApi.serviceStatusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServiceApi - factory interface
 */
export const ServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceApiFp(configuration)
    return {
        /**
         * Returns service status and configuration information, including platforms, groups, and aggregation diagnostics.
         * @summary Service status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceStatusGet(options?: RawAxiosRequestConfig): AxiosPromise<VServiceStatusGet200Response> {
            return localVarFp.serviceStatusGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceApi - object-oriented interface
 */
export class ServiceApi extends BaseAPI {
    /**
     * Returns service status and configuration information, including platforms, groups, and aggregation diagnostics.
     * @summary Service status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public serviceStatusGet(options?: RawAxiosRequestConfig) {
        return ServiceApiFp(this.configuration).serviceStatusGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WidgetsApi - axios parameter creator
 */
export const WidgetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns an HTML carousel widget showing upcoming events
         * @summary Carousel HTML widget
         * @param {string} [groups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        widgetCarouselGet: async (groups?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/widget/carousel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (groups !== undefined) {
                localVarQueryParameter['groups'] = groups;
            }

            localVarHeaderParameter['Accept'] = 'text/html';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an HTML widget showing the next upcoming event
         * @summary Next event HTML widget
         * @param {string} [groups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        widgetNextEventGet: async (groups?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/widget/next-event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (groups !== undefined) {
                localVarQueryParameter['groups'] = groups;
            }

            localVarHeaderParameter['Accept'] = 'text/html';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WidgetsApi - functional programming interface
 */
export const WidgetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WidgetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns an HTML carousel widget showing upcoming events
         * @summary Carousel HTML widget
         * @param {string} [groups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async widgetCarouselGet(groups?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.widgetCarouselGet(groups, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WidgetsApi.widgetCarouselGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns an HTML widget showing the next upcoming event
         * @summary Next event HTML widget
         * @param {string} [groups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async widgetNextEventGet(groups?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.widgetNextEventGet(groups, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WidgetsApi.widgetNextEventGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WidgetsApi - factory interface
 */
export const WidgetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WidgetsApiFp(configuration)
    return {
        /**
         * Returns an HTML carousel widget showing upcoming events
         * @summary Carousel HTML widget
         * @param {string} [groups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        widgetCarouselGet(groups?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.widgetCarouselGet(groups, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an HTML widget showing the next upcoming event
         * @summary Next event HTML widget
         * @param {string} [groups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        widgetNextEventGet(groups?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.widgetNextEventGet(groups, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WidgetsApi - object-oriented interface
 */
export class WidgetsApi extends BaseAPI {
    /**
     * Returns an HTML carousel widget showing upcoming events
     * @summary Carousel HTML widget
     * @param {string} [groups] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public widgetCarouselGet(groups?: string, options?: RawAxiosRequestConfig) {
        return WidgetsApiFp(this.configuration).widgetCarouselGet(groups, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an HTML widget showing the next upcoming event
     * @summary Next event HTML widget
     * @param {string} [groups] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public widgetNextEventGet(groups?: string, options?: RawAxiosRequestConfig) {
        return WidgetsApiFp(this.configuration).widgetNextEventGet(groups, options).then((request) => request(this.axios, this.basePath));
    }
}



